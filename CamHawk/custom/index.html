<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selfie Filters</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            display: block;
        }
        
        .filter-carousel {
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        .filter-carousel::-webkit-scrollbar {
            height: 4px;
        }
        
        .filter-carousel::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .filter-carousel::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-black">
    <div class="flex flex-col h-screen w-full bg-black">
        <!-- Camera Preview -->
        <div class="flex-1 flex items-center justify-center bg-black relative overflow-hidden">
            <video id="video" class="hidden" playsinline autoplay></video>
            <canvas id="canvas" class="w-full h-full object-cover"></canvas>
        </div>

        <!-- Filter Carousel -->
        <div class="bg-gray-900 py-4 px-4">
            <div class="filter-carousel flex gap-3 pb-2">
                <button class="filter-btn flex-shrink-0 flex flex-col items-center gap-2 active" data-filter="none">
                    <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-gray-600 to-gray-800 border-2 border-white"></div>
                    <span class="text-white text-xs font-medium">Normal</span>
                </button>
                
                <button class="filter-btn flex-shrink-0 flex flex-col items-center gap-2" data-filter="grayscale">
                    <div class="w-16 h-16 rounded-lg bg-gray-400 border-2 border-gray-400"></div>
                    <span class="text-white text-xs font-medium">B&W</span>
                </button>
                
                <button class="filter-btn flex-shrink-0 flex flex-col items-center gap-2" data-filter="sepia">
                    <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-yellow-900 to-yellow-700 border-2 border-yellow-600"></div>
                    <span class="text-white text-xs font-medium">Sepia</span>
                </button>
                
                <button class="filter-btn flex-shrink-0 flex flex-col items-center gap-2" data-filter="cool">
                    <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-blue-400 to-blue-600 border-2 border-blue-300"></div>
                    <span class="text-white text-xs font-medium">Cool</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const filterBtns = document.querySelectorAll('.filter-btn');

        let currentFilter = 'none';

        // Start camera
        navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' },
            audio: false
        }).then(stream => {
            video.srcObject = stream; 
            video.onloadedmetadata = () => {
                video.play();
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawFrame();
            };
        }).catch(err => {
            console.error('Error accessing camera:', err);
            alert('Please allow camera access to use this app');
        });

        // Apply filter to canvas
        function applyFilter(filter) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            switch(filter) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg;
                        data[i + 1] = avg;
                        data[i + 2] = avg;
                    }
                    break;
                    
                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                    }
                    break;
                    
                case 'cool':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = data[i] * 0.8;     // Reduce red
                        data[i + 2] = data[i + 2] * 1.2; // Increase blue
                    }
                    break;
                    
                case 'none':
                default:
                    // No filter
                    return;
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
            
        // Draw frame with filter
        function drawFrame() {
            const containerWidth = canvas.width;
            const containerHeight = canvas.height;
            
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = containerWidth / containerHeight;
            
            let sourceX, sourceY, sourceWidth, sourceHeight;
            
            // Cover the canvas (crop video to fill, maintaining aspect ratio)
            if (videoAspect > canvasAspect) {
                // Video is wider - crop sides
                sourceHeight = video.videoHeight;
                sourceWidth = sourceHeight * canvasAspect;
                sourceX = (video.videoWidth - sourceWidth) / 2;
                sourceY = 0;
            } else {
                // Video is taller - crop top/bottom
                sourceWidth = video.videoWidth;
                sourceHeight = sourceWidth / canvasAspect;
                sourceX = 0;
                sourceY = (video.videoHeight - sourceHeight) / 2;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw video without mirroring
            ctx.drawImage(
                video,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, canvas.width, canvas.height
            );
            
            // Apply selected filter
            applyFilter(currentFilter);
            
            requestAnimationFrame(drawFrame);
        }

        // Filter button clicks
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
            });
        });
    </script>
    <script src="script.js"></script>
</body>
</html>